---
layout: post
title: leetcode coding
date: 2019-12-16
categories: test
tags: leetcode 
---

[TOC]



[LeetCode All in One 题目讲解汇总(持续更新中...)](https://www.cnblogs.com/grandyang/p/4606334.html)
# 1. 两数之和
https://leetcode-cn.com/problems/two-sum/
## 题目
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

## 示例
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

## 解决

最好是使用hashmap去解决，这样的时间复杂度是O(n).

hashmap: http://www.runoob.com/java/java-map-interface.html

hashmap是<K, V>键值对，它的语法要注意一下特别是：
- 定义
- 一些用法
   - containsKey(Object k)： 如果此映射包含指定键的映射关系，则返回 true
   - boolean containsValue(Object v)： 如果此映射将一个或多个键映射到指定值，则返回 true。
   - put(Object k, Object v)：将指定的值与此映射中的指定键关联
   - size(): 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。
   - Object get(Object k):返回指定键所映射的值；如果此映射不包含该键的映射关系，则回 null。,注意是 给 键去查找 值，单向的，如果需要翻过来，可以考虑在建立map的时候就反着建。

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> m = new HashMap<Integer, Integer>(); // 定义一个HashMap
        int[] res = new int[2];
        // 定义HashMap 中的映射关系
        for(int i = 0; i < nums.length; i++) {
            m.put(nums[i], i); //注意这里是将数组的值作为key，将数组的下标作为value   
        }
        
        for(int i = 0; i < nums.length; i++) {
            int t = target - nums[i];
            if(m.containsKey(t) && m.get(t) != i) { // 注意containskey 和 get 方法的使用
                res[0] = i;
                res[1] = m.get(t);
                break;
            }
        }
        return res;
    }
}
```
# 2. 两数相加
   
https://leetcode-cn.com/problems/add-two-numbers/

## 题目
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

## 示例
```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

## 解决
建立一个新链表，然后把输入的两个链表从头往后撸，每两个相加，添加一个新节点到新链表后面。为了避免两个输入链表同时为空，我们建立一个dummy结点，将两个结点相加生成的新结点按顺序加到**dummy结点**之后，由于dummy结点本身不能变，所以我们用一个指针cur来指向新链表的最后一个结点。

好，可以开始让两个链表相加了，这道题好就好在最低位在链表的开头，所以我们可以在遍历链表的同时按从低到高的顺序直接相加。while循环的条件两个链表中只要有一个不为空行，由于链表可能为空，所以我们在取当前结点值的时候，先判断一下，若为空则取0，否则取结点值。然后把两个结点值相加，同时还要加上进位carry。然后更新carry，直接 sum/10 即可，然后以 sum%10 为值建立一个新结点，连到cur后面，然后cur移动到下一个结点。之后再更新两个结点，若存在，则指向下一个位置。

while循环退出之后，最高位的进位问题要最后特殊处理一下，若carry为1，则再建一个值为1的结点，
## 注意
- 要考虑某个节点为空的情况，比如一个是两位的一个是三位的
- 要考虑进位的问题
- 要考虑建立一个dummy节点去保存结果。
- 要考虑循环结束之后进位的问题，有可能多了一位。
- 学会怎么创建链表，以及带头节点的情况。
- 链表的循环一般使用是while循环。


```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(-1);//创建一个dummy节点存储新链表,注意这里是带头节点的链表。
        ListNode cur = dummy;// dummy节点不能动，使用一个cur作为游标
        int carry = 0; // 进位
        while(l1 != null || l2 != null) {
            int d1 = (l1 == null ? 0 : l1.val);
            int d2 = (l2 == null ? 0 : l2.val);
            int sum = d1 + d2 + carry;
            carry = (sum < 10 ? 0 : 1 );
            // 记一下创建节点的方式
            cur.next = new ListNode(sum % 10);
            // 都结束，记得指针的移动
            cur = cur.next;
            if(l1 != null) l1 = l1.next;
            if(l2 != null) l2 = l2.next;
        }
        if(carry == 1) cur.next = new ListNode(1); // 循环结束的时候，不要忘记最高位可能出现进位
        return dummy.next; //因为是带头节点的链表，所以最后返回的时候要res.next
    }
}
```
# 3. 最长无重复字符的子串
https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/
## 题目
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
## 示例
```
示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

## 解决
### 思路
一个字符一个字符的遍历，比如a，b，c，然后又出现了一个a，那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉一次出现的b，以此类推，最终发现最长的长度为3。

以说，我们需要记录之前出现过的字符，记录的方式有很多，最常见的是统计字符出现的个数，但是这道题字符出现的位置很重要，所以我们可以使用HashMap来建立字符和其出现位置之间的映射。进一步考虑，由于字符会重复出现，到底是保存所有出现的位置呢，还是只记录一个位置？我们之前手动推导的方法实际上是维护了一个滑动窗口，窗口内的都是没有重复的字符，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以我们只关心每个字符最后出现的位置，并建立映射。窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，我们需要一个变量left来指向滑动窗口的左边界，这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，如果之前出现过，那么就分两种情况，在或不在滑动窗口内，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位一位向右遍历查找，由于我们的HashMap已经保存了该重复字符最后出现的位置，所以直接移动left指针就可以了。我们维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果啦。

这里我们可以建立一个HashMap，建立每个字符和其最后出现位置之间的映射，然后我们需要定义两个变量res和left，其中res用来记录最长无重复子串的长度，left指向该无重复子串左边的起始位置的前一个，由于是前一个，所以初始化就是-1，然后我们遍历整个字符串，对于每一个遍历到的字符，如果该字符已经在HashMap中存在了，并且如果其映射值大于left的话，那么更新left为当前映射值。然后映射值更新为当前坐标i，这样保证了left始终为当前边界的前一个位置，然后计算窗口长度的时候，直接用i-left即可，用来更新结果res，

这种解法使用了set，核心算法和上面的很类似，把出现过的字符都放入set中，遇到set中没有的字符就加入set中并更新结果res，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止：

### 注意
- hashset 的用法 无序不重复的，ArrayList 有序重复，可以从以下代码看一下
```
	public static void main(String[] args) {
		String s = "123456";
		System.out.println(s.charAt(0));
		
		int[] m = new int[10];
		
		Arrays.fill(m, -1);
		System.out.println(Arrays.toString(m));
		
		HashSet<Integer> set = new HashSet<Integer>();
		 
		ArrayList<Integer> arr = new ArrayList<Integer>();
		
		set.add(2);
		set.add(1);
		set.add(3);
		set.add(3);
		
		arr.add(1);
		arr.add(2);
		arr.add(3);
		arr.add(3);
		
		System.out.println(set);
		System.out.println(arr);
	}
```
```
[1, 2, 3]
[1, 2, 3, 3]
```
- string的求长度是 length(), 注意括号，set 求大小是，返回set中的元素个数 size(), 注意括号。

### 代码
设置一个滑动窗口，求这个滑动窗口的最大，就是right不断向前，如果出现和窗口中left元素一样，加入的时候就把left移出窗口，否则就加入增加窗口。


```
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int left = 0, right = 0,  res = 0;// 设置一个窗口left分别指向窗口的左端和右端，res记录移动过程中最大的窗口大小。
        HashSet<Character> set = new HashSet<Character>();
        
        while(right < s.length()) {
            if(!set.contains(s.charAt(right))) {
                set.add(s.charAt(right));
                right++;
                res = Math.max(res, set.size());
                 // res++; 这里不能是 res++，因为不一定加入res就会增大
            } else {
                set.remove(s.charAt(left));
                left ++;
            }
        }
        
        return res;
    }
}
```

# 5. 最长回文子串
https://leetcode-cn.com/problems/longest-palindromic-substring/

## 题目
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

```
示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"
```
## 解决

LeetCode中关于回文串的题共有五道，除了这道，其他的四道为 Palindrome Number， Validate Palindrome， Palindrome Partitioning，Palindrome Partitioning II，我们知道传统的验证回文串的方法就是两个两个的对称验证是否相等，**那么对于找回文字串的问题，就要以每一个字符为中心，像两边扩散来寻找回文串**，这个算法的时间复杂度是O(n*n)，可以通过OJ，就是要注意奇偶情况，由于回文串的长度可奇可偶，比如"bob"是奇数形式的回文，"noon"就是偶数形式的回文，两种形式的回文都要搜索，对于奇数形式的，我们就从遍历到的位置为中心，向两边进行扩散，对于偶数情况，我们就把当前位置和下一个位置当作偶数行回文的最中间两个字符，然后向两边进行搜索，参见代码如下：


### 一些错误
- String 的方法是substring(int, int)不是~~subString~~,注意从beginIndex开始 到 endIndex - 1 开始。
```
返回一个新字符串，该字符串是此字符串的子字符串。子字符串从指定的beginIndex开始，并扩展到索引endIndex - 1处的字符。因此子字符串的长度为endIndex-beginIndex。
```
- .length() 记得加括号
- String longest = ""; 要先赋值，要不然后面没办法求length()
- 注意奇偶情况：对于奇数形式的，我们就从遍历到的位置为中心，向两边进行扩散，对于偶数情况，我们就把当前位置和下一个位置当作偶数行回文的最中间两个字符，然后向两边进行搜索。
- 可以考虑定义一个函数，如果是奇数就从当前

### 代码
```
class Solution {
    public String longestPalindrome(String s) {
        if(s.length() <= 1) return s;
        
        String longest = ""; //这里一定要先赋值初始化一下，要不然后面使用longest.length() 会报错
        String str;

        for(int i = 0; i < s.length() - 1; i++) {
            str = findPalindrome(s, i , i); // 奇数情况就是一个位置开始
            if(str.length() > longest.length()) { longest = str; }
            
            str = findPalindrome(s, i, i + 1);// 偶数的话就是当前位置和下一个位置为中心
            if(str.length() > longest.length()) { longest = str; }
        }
        return longest;
    }
    
    // 定义一个函数，通过给定位置为中心向两边发散来找回文字符串
    public String findPalindrome(String s, int left, int right) {
        while(left >=0 && right <= s.length() - 1 && s.charAt(left) == s.charAt(right)) {
            left--;   // 左边的继续向左边扩散
            right++; // 右边的继续向右边扩散
        }
        return s.substring(left + 1, right);
    }
}
```

# 7. 整数反转
## 题目
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

```
示例 1:

输入: 123
输出: 321
 示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
```

注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

## 解决

- 这里使用数学方法逆向，比较精髓
```
        while(x != 0) {
            pop = x % 10;
            x = x / 10;
            res = res * 10 + pop; 
        }
```
- 使用的溢出的检测也精髓
![image](https://note.youdao.com/yws/res/17747/7482EB12B7E54092AC436278F1254F95)
```
if (res > Integer.MAX_VALUE/10 || (pop > 7 && res == Integer.MAX_VALUE)) { return 0; }
if (res < Integer.MIN_VALUE/10 || (pop < -8 && res == Integer.MIN_VALUE)) { return 0; }
```
- 正负号不影响
- Integer.MAX_VALUE和 Integer.MIN_VALUE的使用，可以推广Float。。。。
### 代码
```
class Solution {
    public int reverse(int x) {
        int res = 0;
        int pop;
        while(x != 0) {
            pop = x % 10;
            x = x / 10;
            
            if (res > Integer.MAX_VALUE/10 || (pop > 7 && res == Integer.MAX_VALUE)) { return 0; }
            if (res < Integer.MIN_VALUE/10 || (pop < -8 && res == Integer.MIN_VALUE)) { return 0; }

            res = res * 10 + pop; 
        }
        return res;
    }
}
```
# 8. 字符串转换整数 (atoi)
https://leetcode-cn.com/problems/string-to-integer-atoi/

## 题目
请你来实现一个 atoi 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

说明：

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  231 − 1]。如果数值超过这个范围，qing返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。
```
示例 1:

输入: "42"
输出: 42
示例 2:

输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
示例 3:

输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
示例 4:

输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
示例 5:

输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。
```

## 解决
### 注意
这题要考虑数字和符号的情况：

1. 若字符串开头是空格，则跳过所有空格，到第一个非空格字符，如果没有，则返回0.

2. 若第一个非空格字符是符号+/-，则标记sign的真假，这道题还有个局限性，那就是在c++里面，+-1和-+1都是认可的，都是-1，而在此题里，则会返回0.

3. 若下一个字符不是数字，则返回0. 完全不考虑小数点和自然数的情况，不过这样也好，起码省事了不少。

4. 如果下一个字符是数字，则转为整形存下来，若接下来再有非数字出现，则返回目前的结果。

5. 还需要考虑边界问题，如果超过了整形数的范围，则用边界值替代当前值。

### 记住的和犯错的
- 判断溢出 ，如 练习7
- 返回一个字符的ascii码，
```
int value=Integer.valueOf('1');//49
int value=Integer.valueOf('a');//97
```
- ascii 码， '0' -- 48，'a' -- 97， 'A' -- 61 
- 注意判断溢出时考虑的符号

> 错误代码 如果是，这里base在while中永远不可能是负的。
```
class Solution {
    public int myAtoi(String str) {
        if(str.isEmpty()) return 0;
        
        int sign = 1, base = 0, i = 0, pop = 0;
        while(i  < str.length() && str.charAt(i) == ' ') { i++; }
        if(i < str.length() && (str.charAt(i) == '+' || str.charAt(i) == '-')) { 
            sign = (str.charAt(i) == '+') ? 1 : -1; 
            i++; // 注意两个i++ ，要增加一个，向后推一位。
        }
        while(i < str.length() && str.charAt(i) >= '0' && str.charAt(i) <= '9') {
            // 判断溢出
            if(base > Integer.MAX_VALUE / 10 || (base == Integer.MAX_VALUE / 10 && (Integer.valueOf(str.charAt(i)) - Integer.valueOf('0')) > 7)) {
                return Integer.MAX_VALUE;
            }
            if(base < Integer.MIN_VALUE / 10 || (base == Integer.MIN_VALUE / 10 && (Integer.valueOf(str.charAt(i)) - Integer.valueOf('0')) < -8)) {
                return Integer.MIN_VALUE;
            }         
            base = base * 10 +  (str.charAt(i) - Integer.valueOf('0'));
            i++;  // 注意两个i++ ，要增加一个，向后推一位。
        }
        
        return base * sign;
    }
}
```
- 注意 i++ 不能漏。

### 代码

```
class Solution {
    public int myAtoi(String str) {
        
        if(str.isEmpty()) return 0;
        
        int sign = 1, base = 0, i = 0;
        while(i  < str.length() && str.charAt(i) == ' ') { i++; }
        if(i < str.length() && (str.charAt(i) == '+' || str.charAt(i) == '-')) { 
            sign = (str.charAt(i) == '+') ? 1 : -1; 
            i++; // i++ 不要忘了递增
        }
        while(i < str.length() && str.charAt(i) >= '0' && str.charAt(i) <= '9') {
            if(base > Integer.MAX_VALUE / 10 || (base == Integer.MAX_VALUE / 10 && (Integer.valueOf(str.charAt(i)) - Integer.valueOf('0')) > 7)) {
                return Integer.MAX_VALUE;
            }
            // 注意这里的负号的溢出与上次的判断不一样哦，上次是 pop < -8, 这次是 > 8 
            if(base < Integer.MIN_VALUE / 10 || (base == Integer.MIN_VALUE / 10 && (Integer.valueOf(str.charAt(i)) - Integer.valueOf('0')) > 8)) {
                return Integer.MIN_VALUE;
            }
            base = base * sign; // 转换一下，要不然下面一步加不了
            base = base * 10 +  (str.charAt(i) - Integer.valueOf('0'));
            i++;  
            base = base * sign; // 转换一下，要不然，base一定是正的
        }
        
        return base;
    }
}
```
# 9. 回文数
## 题目
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

```
示例 1:

输入: 121
输出: true
示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```

## 解决
### 记住和犯错的
- java 没有动态数组，所以在这里需要使用ArrayList存储每一位的int类型，然后再将ArrayList转换为Array，就是先放入ArrayList 然后使用.size() 计算大小，根据大小分配array，达到动态的目的。
```
ArrayList<Integer> al = new ArrayList<Integer>();
// 注意这里的写法
Integer[] arr = al.toArray(new Integer[al.size()]);
```

- 注意如何取int的每一位
```
while (x > 0) {
    pop = x % 10;
    x = x / 10;
    al.add(pop);
}
```
- 注意判断首尾的结束条件
```
for (i = 0; i < al.size()/2; i++) { //这里的结束条件一开始写错，写的i < al.size()/2 + 1
    if (arr[i] != arr[arr.length - i - 1]) { flag = 0; } // 注意这里进行首尾比较的写法
        }
```

### 代码
```
public class Solution {
	public  boolean isPalindrome(int x) {
        int pop, i = 0, flag = 1;
        ArrayList<Integer> al = new ArrayList<Integer>();
        if (x < 0) { return false; }
        while (x > 0) {
            pop = x % 10;
            x = x / 10;
            al.add(pop);
        }
        
        
        Integer[] arr = al.toArray(new Integer[al.size()]); //注意这里动态分配大小的写法，list.toArray
        
        
        for (i = 0; i < al.size()/2; i++) { //这里的结束条件一开始写错，写的i < al.size()/2 + 1
            if (arr[i] != arr[arr.length - i - 1]) { flag = 0; } // 注意这里进行首尾比较的写法
        }
        if (flag == 1) { return true; }
        else { return false; }
    }
}

```
# 10. 正则表达式匹配
## 题目
给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
匹配应该覆盖整个字符串 (s) ，而不是部分字符串。

说明:
- s 可能为空，且只包含从 a-z 的小写字母。
- p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

```
示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
示例 2:

输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
示例 3:

输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
示例 4:

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
示例 5:

输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```
# 11. 盛最多水的容器

## 题目
给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。
![image](https://note.youdao.com/yws/res/17972/C037952AD5CB490088AAFAA7D08CF92B)
```
 输入: [1,8,6,2,5,4,8,3,7]
输出: 49   
```
## 解决
### 注意
- 这里取数组长度是 array.length 注意没有括号，与 string.length(), set.size()不同
- Math.max 和Math.min  的用法
- 暴力发的遍历方法，两个for循环
```
 for(int i = 0; i < height.length; i++) {
            for(int j = i + 1; j < height.length; j++) {
```
### 暴力
在这种情况下，我们将简单地考虑每对可能出现的线段组合并找出这些情况之下的最大面积。
#### 代码
```
class Solution {
    public int maxArea(int[] height) {
        int MaxArea = 0;
        for(int i = 0; i < height.length; i++) {
            for(int j = i + 1; j < height.length; j++) {
                MaxArea = Math.max(MaxArea, Math.min(height[i], height[j]) * (j - i));
            }
        }
        return MaxArea;
    }
}
```

### 双指针法
https://leetcode-cn.com/articles/container-with-most-water/


这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。

我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 maxareamaxarea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxareamaxarea，并将指向较短线段的指针向较长线段那端移动一步。


最初我们考虑由最外围两条线段构成的区域。现在，为了使面积最大化，我们需要考虑更长的两条线段之间的区域。如果我们试图将指向较长线段的指针向内侧移动，矩形区域的面积将受限于较短的线段而不会获得任何增加。但是，在同样的条件下，移动指向较短线段的指针尽管造成了矩形宽度的减小，但却可能会有助于面积的增大。因为移动较短线段的指针会得到一条相对较长的线段，这可以克服由宽度减小而引起的面积减小。

```
class Solution {
    public int maxArea(int[] height) {
        int maxarea = 0, l = 0, r = height.length - 1;
        while(l < r) {
            maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l));
            if(height[l] < height[r]) {
                l++;
            } else {
                r--;
            }
        }
        return maxarea;        
    }
}
```
# 12. 整数转罗马数字
[TOC]
## 题目
罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
- C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内
```
示例 1:

输入: 3
输出: "III"
示例 2:

输入: 4
输出: "IV"
示例 3:

输入: 9
输出: "IX"
示例 4:

输入: 58
输出: "LVIII"
解释: L = 50, V = 5, III = 3.
示例 5:

输入: 1994
输出: "MCMXCIV"
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

## 解决

### 注意
- 这里取出一个int的每一位是从高为开始的, 注意与前面练习的对比，前面是从地位开始的取的。
```
int pop = num / value[i];
num = num % value[i];

```
- 循环条件是 i = i + 2, 因为每隔两位才是 1000 100 10 等数字。


例如整数 1437 的罗马数字为 MCDXXXVII， 我们不难发现，千位，百位，十位和个位上的数分别用罗马数字表示了。 1000 - M, 400 - CD, 30 - XXX, 7 - VII。所以我们要做的就是用取商法分别提取各个位上的数字，然后分别表示出来：
```
100 - C

200 - CC

300 - CCC

400 - CD

500 - D

600 - DC

700 - DCC

800 - DCCC

900 - CM
```
我们可以分为四类，100到300一类，400一类，500到800一类，900最后一类。
### 代码
```
class Solution {
    public String intToRoman(int num) {
        if (num > 3999 || num < 1) { return "-1"; }
        String res = "";
    	char[] symbol = {'M', 'D', 'C', 'L', 'X', 'V', 'I' };
    	int[] value = {1000, 500, 100, 50, 10, 5, 1};
    	// 注意 i = i + 2
        for (int i = 0; i < value.length; i = i + 2) {
			int pop = num / value[i];
			if (pop < 4) { // 小于4 直接当前位叠加
				for (int j = 1; j <= pop; j++) { res += symbol[i]; }
			} else if (pop == 4) { //等于四的时候，需要把小的放在前面
				res = res + symbol[i] + symbol[i - 1];
			} else if (pop > 4 && pop < 9) {
				res += symbol[i - 1];
				for (int j = 6; j <= pop ; j++) {
					res += symbol[i];
				}
			} else if (pop == 9) {
				res = res + symbol[i] + symbol[i - 2];
			}
			num = num % value[i];
		}
    	return res;
    }
}
```
# 13. 罗马数字转整数
## 题目
参考12

## 解决
我们需要用到HashMap数据结构，来将罗马数字的字母转化为对应的整数值，因为输入的一定是罗马数字，那么我们只要考虑两种情况即可：
1. 如果当前数字是最后一个数字，或者之后的数字比它小的话，则加上当前数字。
2. 其他情况则减去这个数字。

### 注意
- HashMap的使用和定义方法，特别是hm.put(key, value) get(key), size(), containsKey(), containsValue(), isEmpty()
```
 HashMap<Character, Integer> hm = new HashMap<Character, Integer>();
 hm.put('M', 1000);
```
![image](https://note.youdao.com/yws/res/18239/BAC3412F3B864103A78CFC6A6BBC0F71)
- 注意String 的charAt(index)方法，不是atChar犯方法。
### 代码
```
class Solution {
    public int romanToInt(String s) {
        int res = 0;
        HashMap<Character, Integer> hm = new HashMap<Character, Integer>();
        hm.put('M', 1000);
        hm.put('D', 500);
        hm.put('C', 100);
        hm.put('L', 50);
        hm.put('X', 10);
        hm.put('V', 5);
        hm.put('I', 1);
        for (int i = 0; i < s.length(); i++) {
            // 注意这里要有一个 i < s.length() - 1 的条件
            if (i < s.length() - 1 && hm.get(s.charAt(i)) < hm.get(s.charAt(i + 1))) {
                res = res - hm.get(s.charAt(i));
            } else {
                res = res + hm.get(s.charAt(i));
            }
        }
        return res;
    }
}
```
# 14. 最长公共前缀
## 问题
编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。
```
示例 1:

输入: ["flower","flow","flight"]
输出: "fl"
示例 2:

输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```

## 解决
这里使用了暴力解法，一个一个进行判断，我这里比较特别的是，在外层for循环遍历的是strs中字符串的char，内循环遍历的是strs中的字符串，意思就是比较每一个的字符串的相应位置的字符，先确定需要遍历的字符，再去遍历字符串。

### 注意和错误
- 一定要先考虑输入的条件，这里我一开始就是没有考虑，然后测试的适合进来的是空数组，一直报错
- 判断数组为空的写法
```
 if (strs == null || (strs != null && strs.length == 0)) { return res; }
```

### 代码
```
class Solution {
    public String longestCommonPrefix(String[] strs) {
        int m = Integer.MAX_VALUE , flag = 1;
        String res = "";
        // 注意要先考虑输入的条件，判断数组为空的写法
        if (strs == null || (strs != null && strs.length == 0)) { return res; }
        for (int i = 0; i < strs.length; i++) { 
            if (strs[i].length() < m) { m = strs[i].length(); }
        }
        
        for (int i = 0; i < m; i++) {// 固定要判断的字符
            for (int j = 1; j < strs.length; j++) { // 遍历字符串
                if (strs[j].charAt(i) != strs[0].charAt(i)) {
                    flag = 0;
                }
            }
            
            if (flag == 1) {
                res = res + strs[0].charAt(i);
            } else {
                break;
            }
        }
        return res;
    }
}
```
# 15. 三数之和
## 题目
给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。
```
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```
## 解决
先对数组进行排序，时间复杂度O(log(n))，然后定好一个数的位置，查找另外两个数的和等于-nums[i]的组合，由于数组排好序了，所以可以从两边往中间走，当结果大于0的时候后边往后退一步，否则前边进一步，时间复杂度O(n^2)，所以时间复杂度为O(n^2)
### 注意
- List 和ArrayList的区别
List是一个接口，而ArrayList是List接口的一个实现类。 

ArrayList类继承并实现了List接口。 

因此，List接口不能被构造，也就是我们说的不能创建实例对象，但是我们可以像下面那样为List接口创建一个指向自己的对象引用，而ArrayList实现类的实例对象就在这充当了这个指向List接口的对象引用。 

所以，二维的list应该这样声明：
```
 List<List><Integer> res = new ArrayList<>();
```
- 注意初始化list保存三个元素的位置，应该在循环中创建list。一开始是在开始位置创建list，就会在同一个list不断添加

- 注意调用排序的写法
```
Arrays.sort(nums); 
```
- 注意双指针往中间走的写法
```
while(l < r) {
    l++;
    r--;
}
```




### 代码
```
	public static List<List><Integer>> threeSum(int[] nums) {
		// 记住这个创建怎么写的
		List<List><Integer>> res = new ArrayList<>();
        int l, r, sum;
        if (nums == null || nums.length < 3) { return res; }
        
        Arrays.sort(nums); // 注意排序方法的写法
        
        for (int i = 0; i <= nums.length - 3; i++) {
            // 当有一个数为正的，就不用再算了，后面加起来肯定大于零
            if (nums[i] > 0) { break; }
            // 如果有相同的就跳过
            if (i > 0 && nums[i] == nums[i - 1]) { continue; }
            l = i + 1;
            r = nums.length - 1;
            while (l < r) {
            	//注意要在这里创建List，一开始在开始位置创建list，就会在同一个list不断添加
            	//一个list三个元素
            	List<Integer> list = new ArrayList<>(); 
                sum = nums[i] + nums[l] + nums[r];
                if (sum == 0) {
                    list.add(nums[i]);
                    list.add(nums[l]);
                    list.add(nums[r]);
                    res.add(list);
                    l++;
                    r--;
                    // 遇到相同的就去掉，因为两个相同，必然三个都相同
                    while (l < r && nums[l] == nums[l - 1]) { l++; }
                    while (l < r && nums[r] == nums[r + 1]) { r--; } 
                } else if (sum > 0) { 
                    r--; 
                } else { 
                    l++; 
                }
            }
        }   
        return res;
    }
```
# 16. 最接近的三数之和
[TOC]
## 题目
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
```
例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
```

## 解决
是在之前那道 3Sum三数之和的基础上又增加了些许难度，那么这道题让我们返回这个最接近于给定值的值，即我们要保证当前三数和跟给定值之间的差的绝对值最小，所以我们需要定义一个变量diff用来记录差的绝对值，然后我们还是要先将数组排个序，然后开始遍历数组，思路跟那道三数之和很相似，都是先确定一个数，然后用两个指针left和right来滑动寻找另外两个数，每确定两个数，我们求出此三数之和，然后算和给定值的差的绝对值存在newDiff中，然后和diff比较并更新diff和结果closest即可

### 注意
- 与 15 结合起来看，
- Math的一系列方法的使用，
https://docs.oracle.com/javase/7/docs/api/
- 之前与15 一样加了这一句`			if (nums[i] > target) { break; }` 结果是错的，因为nums[i + 1] < 0,就可以越加越小，趋向于target。

### 代码
```
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        int l , r, sum, newdiff;
        Arrays.sort(nums);

        // 求最小，上来需要先初始化，然后最小化
        int res = nums[0] + nums[1] + nums[2];
        int diff = Math.abs(target - res);
        for (int i = 0; i < nums.length; i++) {
            // 这句不对，因为nums[i + 1] < 0,就可以越加越小，趋向于target
            if (nums[i] > target) { break; }
            if (i > 0 && nums[i] == nums[i - 1]) { continue; }
            l = i + 1;
            r = nums.length - 1;
            while (l < r) {
                sum = nums[i] + nums[l] + nums[r];
                newdiff = Math.abs(sum - target);
                if (newdiff < diff) {
                    diff = newdiff;
                    res = sum;
                }
                if (sum < target) {
                    l++;
                } else {
                    r--;
                }
                
            }
        }
        return res;
    } 
}
```

# 21. 合并链表
## 题目
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

中文：合并两个有序的链表，然后返回新的链表。新的链表应该是拼接的前面两个链表。

> Example
```
Input: 1->2->4, 1->3->4 

Output: 1->1->2->3->4->4
```

## 实现代码
```
package lab4;
public class MergeTwoSortedLists {
	public static ListNode merge(ListNode l1, ListNode l2) {
        ListNode result = new ListNode(0);
		ListNode p = result;
		while(l1 != null || l2 != null)
		{
			if(l1 == null)
			{
				p.next = l2;
				break;
			}
			if(l2 == null)
			{
				p.next = l1;
				break;
			}
			if(l1.data < l2.data)
			{
				p.next = l1;
				l1 = l1.next;
			}
			else
			{
				p.next = l2;
				l2 = l2.next;
			}
			p = p.next;		
		}
		return result.next;
    }
	

	public static void main(String[] args) {
		// 创建两个链表
		// 第一个链表: 1-> 2 -> 4
		ListNode l1 = new ListNode(1); // 这是第一个链表的第一个节点
		
		ListNode p = l1; // 这个指针节点会从链表的第一个节点一直往下走
		p.next = new ListNode(1);
		p = p.next;
		p.next = new ListNode(2);
		p = p.next;
		p.next = new ListNode(4);
		
		// 第二个链表 1-> 3 -> 4
		ListNode l2 = new ListNode(1);
		ListNode q = l2;
		q.next = new ListNode(3);
		q = q.next;
		q.next = new ListNode(4);
		
		
		ListNode re = merge(l1, l2);
		
		
		
		while (re != null) {
			System.out.println(re.data);
			re = re.next;
		}
	}
}

class ListNode {
	int data;// 元素数值
	ListNode next;// 下一个元素

	
	ListNode(int data) {
		this.data = data;
	}
}

```
# 77. combination 
## 题目
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

For example,
If n = 4 and k = 2, a solution is:

[[2,4],
[3,4],
[2,3],
[1,2],
[1,3],
[1,4],]

## 思路
递归的完成，从n个里选择k个。有两种情况，一种是先选择第一个，然后从剩下的里面选择k-1个；另一种是不选第一个，从剩下的里面选择k个。

## 代码
```
public class Exercise1 {
	public static int getNumOfJewelsInStones(String J, String S) {
		int result = 0;
		for (int i = 0; i < J.length(); i++) {
			for (int j = 0; j < S.length(); j++) {
				if (J.charAt(i) == S.charAt(j)) {
					result++;
				}
			}
		}
		return result;
	}

	public static void main(String[] args) {
		String J = "aA";
		String S = "aAAbbbb";
		System.out.println(getNumOfJewelsInStones(J, S));
	}
}
```
# 79. Word Search
## 题目
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell,where "adjacent" cells are those horizontally or vertically neighboring. 
 The same letter cell may not be used more than once.

> Example:
```
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.
```

## 代码
```
class Solution:
    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        rownums = len(board)
        colnums = len(board[0])
        visited = [[False] * colnums for i in range(rownums)]

        def search(row, col, word):
            if len(word) == 0:
                return True
            if len(word) == 1:
                return word[0] == board[row][col]

            if word[0] == board[row][col]:
                visited[row][col] = True
                # 防止越界 + 在四个方向找没有被访问过的节点
                if row + 1 < rownums and not visited[row + 1][col] \
                        and search(row + 1, col, word[1:]):
                    return True
                if row - 1 >= 0 and not visited[row - 1][col] and \
                        search(row - 1, col, word[1:]):
                    return True
                if col + 1 < colnums and not visited[row][col + 1] and \
                        search(row, col + 1, word[1:]):
                    return True
                if col - 1 >= 0 and not visited[row][col - 1] and \
                        search(row, col - 1, word[1:]):
                    return True
                visited[row][col] = False
            return False

        for row in range(rownums):
            for col in range(colnums):
                if search(row, col, word):
                    return True
        return False


if __name__ == '__main__':
    board = [
        ['A', 'B', 'C', 'E'],
        ['S', 'F', 'C', 'S'],
        ['A', 'D', 'E', 'E']
    ]
    word = 'ABCCED'
    solution = Solution()
    print(solution.exist(board, word))

```
# 104. Maximum Depth of Binary Tree
## 题目

Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Note: A leaf is a node with no children.

> Example
Given binary tree [3,9,20,null,null,15,7],
```
    3
   / \
  9  20
    /  \
   15   7
```

## 实现

 简单的递归。递归条件是，它的最大深度是它左子树的最大深度和右子树最大深度中较大的那个加1。
 
 基础条件是，当遇到空节点时，返回深度为0。该递归的实质是深度优先搜索。
 
 ```
 package lab7;

/*
 *  二叉树的最大深度
 *  
 *  简单的递归。递归条件是，它的最大深度是它左子树的最大深度和右子树最大深度中较大的那个加1。
 *  基础条件是，当遇到空节点时，返回深度为0。该递归的实质是深度优先搜索。
 */

public class MaximumDepthOfBinaryTree {
	public static int getMaxDepth(BinaryNode root) {
		if (root == null) {
			return 0;
		}
		int left = getMaxDepth(root.lchild);
		int right = getMaxDepth(root.rchild);
		return Math.max(left, right) + 1;
	}
	
	public static BinaryNode createBinaryTree() {
		BinaryNode root = new BinaryNode(3);
		root.lchild = new BinaryNode(9);
		root.rchild = new BinaryNode(20);
		root.rchild.rchild = new BinaryNode(15);
		root.rchild.lchild = new BinaryNode(7);
		return root;
	}
	
	public static void main(String[] args) {
		BinaryNode root = createBinaryTree();
		System.out.println(getMaxDepth(root));
	}
}

 ```

# 142. Linked List Cycle && Linked List Cycle II
## 题目

Given	a	linked	list,	return	the	node	where	the	cycle	begins.	If	there	is	no	cycle,	return	null.	

### 实现
#### 先判断有没有环
复杂度O(n)的方法，使用两个指针slow,fast。两个指针都从表头开始走，slow每次走一步，fast每次走两步，如果fast遇到null，则说明没有环，返回false；如果slow==fast，说明有环，并且此时fast超了slow一圈，返回true。

#### 再去找环的入口
令一个指针指向头结点，两个指针此时距离目标节点是相等的。然后两个指针都每次移动一个节点直至重合，即可得到目标节点。**因为头节点到入口节点和相遇节点到入口节点的距离是一样的。**
> why

![image](https://note.youdao.com/yws/res/8020/DA9D963E966E4C759CE5518541F587E0)

## 实现
```
package lab5;

public class LinkedListCycle {
	public static ListNode detectCycle(ListNode head) {
		boolean flag = false;
		if (head == null || head.next == null) {
			return null;
		}

		ListNode fast = head;
		ListNode low = head;

		// find the node that low and fast meeting
		while (fast != null && fast.next != null) {
			fast = fast.next.next;
			low = low.next;

			if (fast == low) {
				flag = true;
				fast = head;
				while (fast != low) {
					fast = fast.next;
					low = low.next;
				}
				break;
			}
		}

		if (!flag) {
			return null;
		}

		return low;
	}

	public static void main(String[] args) {
		// 创建一个链表1 -> 2-> 3-> 4 ->5
		ListNode n1 = new ListNode(1); 
		ListNode n2 = new ListNode(2);
		ListNode n3 = new ListNode(3);
		ListNode n4 = new ListNode(4);
		ListNode n5 = new ListNode(5);
		ListNode n6 = new ListNode(6);
		n1.next = n2;
		n2.next = n3;
		n3.next = n4;
		n4.next = n5;
		n5.next = n6;
		n6.next = n3;
		
		ListNode re = detectCycle(n1);
		
		if (re == null) {
			System.out.println("null");
		} else {
			System.out.println(re.data);
		}

	}

}

class ListNode {
	int data;// 元素数值
	ListNode next;// 下一个元素

	ListNode(int data) {
		this.data = data;
	}
}

```

# 162 矩阵归零
## 题目
给定一个m×n 矩阵，如果某个元素为0，则 将其整个行和列都设置为0
> Example
```
Input: 
[[1,1,1],  
[1,0,1], 
[1,1,1] ] 
Output:  
[[1,0,1], 
[0,0,0], 
[1,0,1] ] 
Input: 
[ [0,1,2,0],
[3,4,5,2],
[1,3,1,5] ] 
Output:  
[[0,0,0,0],   
[0,4,5,0],   
[0,3,1,0 ] 
```

## 代码
```
def setZero(matrix):
    """
    :param matrix:
    :return:
    """
    index_to_setzero = []
    for i in range(len(matrix)):
        for j in range(len(matrix[i])):
            if matrix[i][j] == 0:
                index_to_setzero.append((i, j))

    for  i, j in index_to_setzero:
        matrix[i] = [0] * len(matrix[i])
        for k in  range(len(matrix)):
            matrix[k][j] = 0

def main():
    print("输入二维数组")
    matrix = getMatrix()
    setZero(matrix)
    printMatrix(matrix)

def getMatrix():
    M = int(input("请输入行数："))
    N = int(input("请输入列数："))

    A = [[0] * N] * M # 注意这是零矩阵的初始化方法

    for i in range(M):
        A[i] = input().split(" ") # 将输入变为一维数组
        for j in  range(N):
            A[i][j] = int(A[i][j])
    return A

def printMatrix(matrix):
    for i in range(len(matrix)):
        print(matrix[i])

if __name__ == '__main__':
    main()
```

# 203. Remove Linked List Elements
## 题目
Remove all elements from a linked list of integers that have value val.

> Example
```
Example:

Input:  1->2->6->3->4->5->6, val = 6
Output: 1->2->3->4->5
```

## 代码
```
list = [1, 2, 6, 3, 4, 5, 6]
list2 = [1, 1, 1]


# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def removeElements(self, head, val):
        """
        :type head: ListNode
        :type val: int
        :rtype: ListNode
        """
        if head == None:
            return head
        node = head
        # 从head.next开始检查
        while (node):
            if node.next == None:  # 到了最后一个节点，退出循环
                break
            if node.next.val == val:
                node.next = node.next.next  # 删除节点
            else:
                node = node.next
        # 最后检查head节点的val
        if head.val == val:
            # 最后检查头节点，如果头节点与val相等，删除头节点
            head = head.next

        return head


def createList(list):
    # 循环创建链表
    head = ListNode(list[0])
    t = head

    for i in range(1, len(list)):
        node = ListNode(list[i])
        t.next = node
        t = node

    return head


def display(listNode):
    if listNode == None:
        print("空链表")
        return

    while (listNode):
        print(listNode.val, end='->')
        listNode = listNode.next
    print("None")


if __name__ == '__main__':
    head = createList(list)
    print("原链表：")
    display(head)

    solution = Solution()

    newHead = solution.removeElements(head, 6)
    print("删除后的链表：")
    display(newHead)
```
# 328. OddEvenLinkedList 
## 题目
Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.
You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

> Example
```
Given 1->2->3->4->5->NULL
return 1->3->5->2->4->NULL
```
## 代码实现
![image](https://note.youdao.com/yws/res/8034/72227025D440477EB95DE083C1B8AF83)

```
package lab5;




/*
 给定一个链表，将所有奇数位置节点放在一起，后面放置偶数位置节点


 */
package lab5;

public class OddEvenLinkededList {
	public static ListNode oddEvenList(ListNode head) {
		if (head == null || head.next == null) {
			return head;
		}
		
		ListNode oddNode = head;
		ListNode evenNode = head.next;
		ListNode tmp = evenNode;
		
		while (evenNode != null && evenNode.next != null) {
			oddNode.next = evenNode.next;
			oddNode = oddNode.next;
			evenNode.next = oddNode.next;
			evenNode = evenNode.next;
		}
		
		oddNode.next = tmp;
		return head;
	}

	public static ListNode createList(ListNode head) {
		ListNode p = head;

		p.next = new ListNode(2);
		p = p.next;
		p.next = new ListNode(3);
		p = p.next;
		p.next = new ListNode(4);
		p = p.next;
		p.next = new ListNode(5);
		p = p.next;
		p.next = new ListNode(6);
		p = p.next;

		return p;
	}
	
	
	public static void main(String[] args) {
		
		
		ListNode l1 = new ListNode(1); 

//		ListNode p = l1;
//
//		p.next = new ListNode(2);
//		p = p.next;
//		p.next = new ListNode(3);
//		p = p.next;
//		p.next = new ListNode(4);
//		p = p.next;
//		p.next = new ListNode(5);
//		p = p.next;
//		p.next = new ListNode(6);
	
		ListNode p = createList(l1);
		
//		ListNode re = oddEvenLit(p);
		ListNode re = oddEvenList(l1); // 应该使用的是l1，因为此时p已经指向了最后一个节点
		while (re != null) {
			System.out.println(re.data);
			re = re.next;
		}
	}
}


```


# 617. Merge Two Binary Tree
## 题目
Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. 
给定两个二叉树，并想象当你把其中一个覆盖另一个时，两个树的一些节点是重叠的，而另一个没有。

You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.

您需要将它们合并成一个新的二叉树。合并规则是如果两个节点重叠，则sum节点值作为合并节点的新值。否则，NOT空节点将被用作新树的节点。

> Example

```
Example 1:
Input: 
    Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
Output: 
Merged tree:
         3
        / \
       4   5
      / \   \ 
     5   4   7

```

## 解决

先序递归遍历二叉树，从根节点开始求和

> 代码

注意这里用到的PrintBinaryTree.printTree(b1)方法; 
```
package lab6;
/*
 * 合并成一个新的二叉树。合并规则是如果两个节点重叠，则sum节点值作为合并节点的新值。否则，NOT空节点将被用作新树的节点。
 */
import lab6.PrintBinaryTree;

public class MergeTwoBinaryTrees {
	/*
	 * 创建第一颗二叉树
	 */
	public static void createBinaryTree1(BinaryNode head) {
		BinaryNode p = head;
		p.lchild = new BinaryNode(3);
		p.rchild = new BinaryNode(2);
		p.lchild.lchild = new BinaryNode(5);
	}
	/*
	 * 创建第二颗二叉树
	 */
	public static void createBinaryTree2(BinaryNode head) {
		BinaryNode p = head;
		p.lchild = new BinaryNode(1);
		p.rchild = new BinaryNode(3);
		p.lchild.rchild = new BinaryNode(4);
		p.rchild.rchild = new BinaryNode(7);
	}
	
	// 合并二叉树
	public static BinaryNode mergeBinaryTree(BinaryNode b1, BinaryNode b2) {
		 
		// 考虑空节点的情况,
		if (b1 == null && b2 == null) {
			return null;
		} else if (b1 == null) {  //如果b1为空，返回b2
			return b2;
		} else if (b2 == null) {
			return b1;
		}
		
		
		// 先序遍历，对节点求和
		b1.data = b1.data + b2.data;
		b1.lchild = mergeBinaryTree(b1.lchild,b2.lchild);
		b1.rchild = mergeBinaryTree(b1.rchild, b2.rchild);
		
		return b1;  
	}
	
	
	
	
	public static void main(String[] args) {
		BinaryNode b1 = new BinaryNode(1);
		BinaryNode b2 = new BinaryNode(2);
		
		createBinaryTree1(b1);
		createBinaryTree2(b2);
		
		
		PrintBinaryTree.printTree(b1);
		PrintBinaryTree.printTree(b2);
		
		b1 = mergeBinaryTree(b1, b2);
		
		//打印b1
		PrintBinaryTree.printTree(b1); 
		
	}
}


class BinaryNode {
	int data;
	BinaryNode lchild;
	BinaryNode rchild;
	
	public BinaryNode(int data) {
		this.data = data;
	}
}
```

# 654. Maximum Binary Tree
## 题目
Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:

1. The root is the maximum number in the array.
2. The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.
3. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.

> Example

Construct the maximum tree by the given array and output the root node of this tree.
```

Input: [3,2,1,6,0,5]
Output: return the tree root node representing the following tree: 
      6 
    /   \ 
   3     5 
    \    /  
     2  0    
       \ 
        1
```


## 实现
```
public class MaximumBinaryTree {
	public static int getMaxIndex(int[] num, int start, int end) {
		int max_i = start;
		for (int i = start; i < end; i++) {
			if (num[max_i] < num[i]) {
				max_i = i;
			}
		}
		return max_i;
	}
	
	public static BinaryNode construct(int[] num,int start, int end) {
		if (start == end) {
			return null;
		}
		int max_i = getMaxIndex(num, start, end);
		BinaryNode root = new BinaryNode(num[max_i]);
		root.lchild = construct(num, start, max_i);
		root.rchild = construct(num, max_i + 1, end);
		return root;
	}
	
	public static void main(String[] args) {
		int[] num = {3, 2, 1, 6, 0, 5};
		
		BinaryNode head = construct(num, 0, 5);
		
		PrintBinaryTree.printTree(head);
	}
}

class BinaryNode {
	int data;
	BinaryNode lchild;
	BinaryNode rchild;
	
	public BinaryNode(int data) {
		this.data = data;
	}
}
```

# 700. Search in a Binary Search Tree
## 题目
给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

> Example
```
Given the tree:  

        4
       / \      
      2   7   
     / \
    1   3
    
And the value to search:
You should return this subtree: 

      2    
     / \-
    1   3
```

## 解决
BST的搜索，比根节点小，查找左子树; 比根节点小，查找右子树；等于根节点，返回根节点。

```
package lab6;

public class SearchInBinaryTree {
	public static void createBinaryTree3(BinaryNode head) {
		BinaryNode p = head;
		p.lchild = new BinaryNode(2);
		p.rchild = new BinaryNode(7);
		p.lchild.lchild = new BinaryNode(1);
		p.lchild.rchild = new BinaryNode(3);
	}
	
	// BST的搜索
	public static BinaryNode search(BinaryNode p, int val) {
		if (p == null) {
			return null;
		}
		if (val < p.data) {
			return search(p.lchild, val);
		} else if (val > p.data) {
			return search(p.rchild, val);
		} else {
			return p;
		}
	}
	
	public static void main(String[] args) {
		BinaryNode b3 = new BinaryNode(4);
		
		createBinaryTree3(b3);
		
		BinaryNode p =search(b3, 2);
		
		PrintBinaryTree.printTree(p);
	}
}
```
# 771. Jewels and Stones
## 题目
You’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels.
The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.

Example 1:

Input: J = "aA", S = "aAAbbbb"
Output: 3

Example 2:

Input: J = "z", S = "ZZ"
Output: 0

Note:

S and J will consist of letters and have length at most 50.
The characters in J are distinct.

## 解决
回溯法：
1. 递归一次，填入一个数字
2. 填入的数字，不能是小于当前数字的值，防止重复
3. 回溯：回溯到上一层。
4. 结束条件：填写够了k个数字的时候，当前填写完毕，回溯

```
import java.util.ArrayList;
import java.util.List;

/*
 	Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. 
 */
public class Exercise2 {
	    public static ArrayList<ArrayList><Integer>> combine(int n, int k) {
	    	//保存结果
	        ArrayList<ArrayList><Integer>> result = new ArrayList<ArrayList><Integer>>();
	        //保存挑选出来的数组
	        ArrayList<Integer> subset = new ArrayList<Integer>();
	        int[] num = new int[n];
	        for (int j = 0; j < n; j++) {
	            num[j] = j + 1;
	        }
	        subsets(n, k, num, 0, subset, result);
	        return result;
	    }

	    private static void subsets(int n, int k, int[] num, int begin,
	            ArrayList<Integer> subset, ArrayList<ArrayList><Integer>> result) {
	        if (subset.size() == k) {
	            ArrayList<Integer> c = new ArrayList<Integer>(subset);
	            result.add(c);
	        } else {
	            for (int i = begin; i < num.length; i++) {
	                subset.add(num[i]);
	                subsets(n, k, num, i + 1, subset, result);
	                subset.remove(subset.size() - 1);
	            }
	        }
	    }
	    
	    public static void main(String args[])
	    {

	        ArrayList<ArrayList><Integer>> result = combine(5,3);
	        for(int i = 0; i < result.size(); i++)
	        {
	            System.out.print(result.get(i));
	        }
	    }
}
```



# 876. Middle of the Linked List
## 题目
给定具有头节点头的非空的单链表，返回链表的中间节点。
如果有两个中间节点，则返回第二个中间节点。
> Example 1
```
Input: [1,2,3,4,5] 
Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3.  (The judge's serialization of this node is [3,4,5]).
Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.ne xt = NULL. 
```

> Example 2
```
Input: [1,2,3,4,5,6] 
Output: Node 4 from this list (Serialization: [4,5,6])
Since the list has two middle nodes with values 3 and 4, we return the sec ond one. 
```

## 实现代码
```
package lab4;

public class MiddleNode {

	public static ListNode middleNode(ListNode head) {
		if (head == null || head.next == null)
			return head;
		ListNode slow = head;
		ListNode fast = head;
		while (fast != null && fast.next != null) {
			fast = fast.next.next;
			slow = slow.next;
		}
		

		if (fast.next  == null) {
			return slow.next;
		}
		else {
			return slow;
		}
	}

	public static void main(String[] args) {
		// 创建一个链表1 -> 2-> 3-> 4 ->5
		ListNode l1 = new ListNode(1); // 这是第一个链表的第一个节点

		ListNode p = l1;
		p.next = new ListNode(1);
		p = p.next;
		p.next = new ListNode(2);
		p = p.next;
		p.next = new ListNode(3);
		p = p.next;
		p.next = new ListNode(4);
		p = p.next;
		p.next = new ListNode(5);
		p = p.next;
		p.next = new ListNode(6);

		ListNode re = middleNode(l1);
		while (re != null) {
			System.out.println(re.data);
			re = re.next;
		}
	}

}

```

















































